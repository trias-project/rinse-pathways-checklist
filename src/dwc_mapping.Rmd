---
title: "Darwin Core mapping"
subtitle: "For: RINSE - pathways and vectors of biological invasions in Northwest Europe"
author:
- Lien Reyserhove
- Peter Desmet
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    number_sections: true
---

This document describes how we map the checklist data to Darwin Core. The source file for this document can be found [here](https://github.com/trias-project/rinse-pathways-checklist/tree/master/data/raw).

# Setup

```{r setup, echo = FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

Set locale (so we use UTF-8 character encoding):

```{r}
# This works on Mac OS X, might not work on other OS
Sys.setlocale("LC_CTYPE", "en_US.UTF-8")
```

Load libraries:

```{r}
library(tidyverse) # To transform data
library(magrittr)  # For %<>% pipes
library(janitor)   # To clean input data
library(readxl)    # To read Excel files
library(stringr)   # To perform string operations
library(digest)    # To generate hashes
library(rgbif)     # Interface to the GBIF API
library(purrr)     # To clean references
```

Set file paths (all paths should be relative to this script):
 
```{r}
# Raw files:
raw_data_file = "../data/raw/copy_of_10530_2016_1278_MOESM2_ESM.xlsx"
references = "../data/raw/references.xlsx"

# Processed files:
dwc_taxon_file = "../data/processed/taxon.csv"
dwc_literature_references_file = "../data/processed/literature_references.csv"
dwc_distribution_file = "../data/processed/distribution.csv"
dwc_profile_file = "../data/processed/speciesprofile.csv"
dwc_description_file = "../data/processed/description.csv"
```

# Read and pre-process raw data

Create a data frame `raw_data` from the source data:

```{r}
raw_data <- read_excel(path = raw_data_file) 
```

Clean the data somewhat: remove empty rows if present and clean names:

```{r}
raw_data %<>% remove_empty_rows() %<>%     # Remove empty rows
  clean_names()
```

## Clean scientific name

Before we assign a taxonID to the scientific names (in `species`), we need to clean the information. We do this stepwise by using the `parsenames()` function provided by rgbif. 

```{r}
parsed_names <- parsenames(raw_data $ species)
```

In this checklist, all specificEpithets should be populated. This is not always the case. Some cleaning was required:

```{r}
raw_data %<>% mutate(species_clean = case_when(
  species == "Crassostrea rhizophoraeGuilding 1828" ~ "Crassostrea rhizophorae Guilding 1828",
  species == "Petricola pholadiformisLamarck, 1818" ~ "Petricola pholadiformis Lamarck, 1818",
  species == "Theba pisanaMüller, 1774)" ~ "Theba pisana (Müller, 1774)",
  species == "Maylandia sp. M. K. Meyer & W. Förster, 1984" ~ "Maylandia M. K. Meyer & W. Förster, 1984",
  TRUE ~ species)) 
```

## Generate taxonID

To uniquely identify a taxon in the taxon core and reference taxa in the extensions, we need a `taxonID`. Since we need it in all generated files, we generate it here in the raw data frame. It is a combination of `dataset-shortname:taxon:` and a hash based on the scientific name. As long as the scientific name doesn't change, the ID will be stable:

```{r}
# Vectorize the digest function (The digest() function isn't vectorized. So if you pass in a vector, you get one value for the whole vector rather than a digest for each element of the vector):
vdigest <- Vectorize(digest)

# Generate taxonID:
raw_data %<>% mutate(taxonID = paste("rinse-pathways-checklist", "taxon", vdigest (species_clean, algo="md5"), sep=":"))
```

## Further pre-processing:

Add prefix `raw_` to all column names to avoid name clashes with Darwin Core terms:

```{r}
colnames(raw_data) <- paste0("raw_", colnames(raw_data))
```

Preview data:

```{r}
raw_data %>% head()
```

# Create taxon core

```{r start_taxon}
taxon <- raw_data
```

## Term mapping
 
Map the data to [Darwin Core Taxon](http://rs.gbif.org/core/dwc_taxon_2015-04-24.xml).
 
### language

```{r}
taxon %<>% mutate(language = "en")
```

### rightsHolder

```{r}
taxon %<>% mutate(rightsHolder = "University of Cambridge")
```

### datasetID

```{r}
taxon %<>% mutate(datasetID = "")
```

### datasetName

```{r}
taxon %<>% mutate(datasetName = "RINSE - pathways and vectors of biological invasions in Northwest Europe")
```

### taxonID

```{r}
taxon %<>% mutate(taxonID = raw_taxonID)
```

### scientificName

```{r}
taxon %<>% mutate(scientificName = raw_species_clean)
```

### kingdom

Information for the higher classification is contained in `raw_higher_classification`:

```{r}
taxon %>% distinct(raw_higher_classification)
```

These map to different taxonomical levels (e.g. `Mammalia` = class while `Osteichthyes` = order). We interpret this information in the mapping of `kingdom`, `phylum`, `class` and `order`. However, not all classification information could be mapped to these Darwin Core terms, e.g. Angiosperms are currently considered to be unranked. For this group, we use the Darwin Core terms `higherClassification`.

```{r}
taxon %<>% mutate(kingdom = case_when(
  raw_higher_classification == "Angiospermae" ~ "Plantae" ,
  TRUE ~ "Animalia")) 
```

### phylum

```{r}
taxon %<>% mutate(phylum = case_when(
  raw_higher_classification == "Angiospermae" ~ "" ,
  raw_higher_classification == "Mollusca" ~ "Mollusca",
  TRUE ~ "Chordata")) 
```

### class

```{r}
taxon %<>% mutate(class = case_when(
  raw_higher_classification == "Anseriformes" ~ "Aves",
  raw_higher_classification == "Mammalia" ~ "Mammalia",
  raw_higher_classification == "Osteichthyes" ~ "Actinopterygii",  # Osteichthyes is an unaccepted synonym
  TRUE ~ "")) 
```

### order

```{r}
taxon %<>% mutate(order = case_when(
  raw_higher_classification == "Anseriformes" ~ "Anseriformes",
  TRUE ~ "" )) 
```

### higherClassification

```{r}
taxon %<>% mutate(higherClassification = case_when(
  raw_higher_classification == "Angiospermae" ~ paste(kingdom, raw_higher_classification, sep = " | "),
  raw_higher_classification == "Mollusca" ~ paste(kingdom, phylum, sep = " | "),
  raw_higher_classification == "Osteichthyes" ~ paste(kingdom, phylum, class, sep = " | "),
  raw_higher_classification == "Anseriformes" ~ paste(kingdom, phylum, class, order, sep = " | "),
  raw_higher_classification == "Mammalia" ~ paste(kingdom, phylum, class, sep = " | "))) 
```

### taxonRank

The information for `taxonRank` can be provided by the nameparser() function of rgbif. We generate it here and add the information to `taxon`:

```{r}
taxonRank <- parsenames(taxon $ raw_species_clean)
```

Select taxonRank information (in `rankmarker`). The field `notho` contains valuable information for the generic hybrids, so this column is selected as well. 

```{r}
taxonRank %<>% select(scientificname, rankmarker, notho) 
```

Merge `taxonRank` with `taxon`:

```{r}
taxon %<>% left_join(taxonRank, by = c("raw_species_clean" = "scientificname")) 
```

Show unique values for `rankmarker`:

```{r}
taxon %>% select(rankmarker, notho) %>% 
  group_by_all() %>% 
  summarise(records = n())
```

Show scientificNames for which rankmarker = NA:

```{r}
taxon %>% select(scientificName, rankmarker) %>% 
  filter(is.na(rankmarker))
```

`Maylandia M. K. Meyer & W. Förster, 1984` is a genus, the other two records are species.
Map `taxonRank`:

```{r}
taxon %<>% mutate(taxonRank = case_when(
  !is.na(notho) ~ "hybrid",
  rankmarker == "sp." & is.na(notho) ~ "species",
  rankmarker == "infrasp." ~ "subspecies",
  is.na(rankmarker) & scientificName != "Maylandia M. K. Meyer & W. Förster, 1984" ~ "species",
  scientificName == "Maylandia M. K. Meyer & W. Förster, 1984" ~ "genus")) 
```

## Post-processing

Remove the original columns:

```{r}
taxon %<>% select(-starts_with("raw_"), -rankmarker, - notho)
```

Preview data:

```{r}
head(taxon)
```

Save to CSV:

```{r}
write.csv(taxon, file = dwc_taxon_file, na = "", row.names = FALSE, fileEncoding = "UTF-8")
```

# Create literature reference extension

```{r}
literature_references <- raw_data
```

## Pre-processing

Information for the literature references is contained in `raw_references`, which are numbers. The link between these numbers and the full references is provided in the [Supplementary material file](https://github.com/trias-project/rinse-pathways-checklist/blob/master/data/raw/10530_2016_1278_MOESM2_ESM.docx). We copy-pasted this information in a separated excel file (with some basic cleaning):

```{r}
compiled_references <- read_excel(path = references, col_types = "text")
```

To merge the full references in `compiled references` with the reference numbers provided in `raw_references` (using the field `identifier`), we need to clean and separate`raw_references` first. Concretely, we aim to provide **all** reference numbers in `raw_references`, instead of using the format containing `-` for a range of numbers between a delimited minimun and maximum (e.g. 3-7 is transformed to 3,4,5,6,7). To accomplish this, we first generate the function `colon_to_seq()`:

```{r}
colon_to_seq <- function(input){
  seq_locs <- gregexpr("\\d+-\\d+", input)
  matched <- regmatches(input, seq_locs)[[1]]
  
  split_support <- function(text) {
    split_seq <- strsplit(text, "-")[[1]]
    paste(as.character(seq(split_seq[1], split_seq[2])), collapse = ",")
  }
  
  regmatches(input, seq_locs, invert = FALSE) <- list(map_chr(matched, split_support))
  input
}
```

Apply cleaning functions:

```{r}
literature_references %<>% 
  rowwise() %<>%
  mutate(raw_references_clean = colon_to_seq(raw_references)) 
```

In a second step, we transform `literature_references` from a wide to a long dataset, with each row containing one reference number per taxon:

```{r}
literature_references %<>%
  mutate(references_sep = raw_references_clean) %<>% 
  ungroup() %<>%
  separate_rows(references_sep, sep = ",")
```

Merge `literature_references` with `compiled_references` to link the reference number with the full reference:

```{r}
literature_references %<>% left_join(compiled_references, by = c("references_sep" = "number"))
```

This dataframe constitutes the basis for further mapping of the literature reference extension. 

For the mapping of the other extensions, we need to translate the sequence of reference numbers given for each taxon in `raw_references` into a sequence of all identifiers corresponding to these specific numbers, separated by `|`. We generate this sequence here, link it with `raw_references` and save it as the dataframe `identifier_sequence`. 

Generate dataframe `identifier_sequence` with the required columns (add taxonID as this is necessary for implying the spread() function): 

```{r}
identifier_sequence <- literature_references %>% select(raw_taxonID, raw_references, references_sep, identifier)
```

To generate the required sequence of identifiers, we need to transform the dataset from one containing one identifier per taxon per row, to one containing a sequence of identifiers per taxon per row. We do this by using the `spread()`function first, generating 33 identifier columns, corresponding to the 33 identifiers: 

```{r}
identifier_sequence %<>% mutate(references_sep = as.numeric(references_sep)) %<>% 
  spread(references_sep, identifier) %<>%
  select(-`<NA>`)
```

In the following step, we unite these 33 columns into one field `id_sequence`, using `|` as a separator.
To efficiently unite the identifier columns (`1-33`), we need to rename the column names by adding the prefix `ref`:

```{r}
old_names <- c("raw_taxonID", "raw_references", c(1:33))
new_names <- c("raw_taxonID", "raw_references", paste("ref", c(1:33), sep = ":"))
identifier_sequence %<>% rename_at(vars(old_names), ~ new_names) 
```

Unite the 33 identifier columns into `id_sequence`:

```{r}
identifier_sequence %<>% unite("id_sequence", c(paste("ref", c(1:33), sep = ":")), sep = " | ")
```

Remove `NA`'s from the generated sequences:

```{r}
identifier_sequence %<>% mutate(id_sequence = str_replace_all(id_sequence, "(([NA]{2}\\s[|]) | [|]\\s([NA]{2}))", ""))
```

Remove `raw_taxonID`:

```{r}
identifier_sequence %<>% select(-raw_taxonID) 
```

Remove duplicate rows:

```{r}
identifier_sequence %<>% distinct(raw_references, .keep_all = TRUE)
```

We will use this dataframe to link the sequence of references numbers with the sequence of identifiers in the mapping of the following extensions.

## Term mapping

Map the data to [Literature References](http://rs.gbif.org/extension/gbif/1.0/references.xml).
### taxonID

```{r}
literature_references %<>% mutate(taxonID = raw_taxonID)
```

### identifier

```{r}
literature_references %<>% select(-identifier, everything()) 
```

### bibliographicCitation

```{r}
literature_references %<>% mutate(bibliographicCitation = full_reference) 
```

## Post-processing

Remove the original columns:

```{r}
literature_references %<>% select(-starts_with("raw_"), -references_sep, -full_reference)
```

Preview data:

```{r}
head(literature_references)
```

Save to CSV:

```{r}
write.csv(literature_references, file = dwc_literature_references_file, na = "", row.names = FALSE, fileEncoding = "UTF-8")
```

# Create distribution extension

```{r start_distribution}
distribution <- raw_data
```

### pre-processing

Information for the distributions and associated dates of first observation is contained in eight columns in total: 4 columns for the distribution information (Great Brittain, France, Belgium and the Netherlands in resp. `raw_established_gb`, `raw_established_france`, `raw_established_belgium` and `raw_established_netherlands`) and 4 columns for the first record of the taxon in these countries (resp. `raw_first_record_gb`, `raw_first_record_france`, `raw_first_record_belgium` and `raw_first_record_netherlands`). When a taxon is present in a country, this is indicated by a `Y` and a date of first record is provided. 

We need to reduce the information to two columns: one with country presence information (`country column`, basis for mapping of `locality`, `locationID` and `countryCode`) and one with the date of first observance (`date` column, basis for mapping of `eventDate`). We do this in three steps:

1. Paste date and establishment information for each country into one column:

```{r}
distribution %<>% mutate(record_gb = paste(raw_established_gb, raw_first_record_gb, sep = ","))  %<>% 
  mutate(record_fr = paste(raw_established_france, raw_first_record_france, sep = ",")) %<>% 
  mutate(record_be = paste(raw_established_belgium, raw_first_record_belgium, sep = ",")) %<>%
  mutate(record_nl = paste(raw_established_netherlands, raw_first_record_netherlands, sep = ",")) 
```

2. Generate `country` and `date` by gathering the new columns:

```{r}
distribution %<>% gather("country", "date", record_gb, record_fr, record_be, record_nl) 
```

3. Remove records with `NA,NA` (not present in the country and thus no date information) and the date information by removing `Y`:

```{r}
distribution %<>% filter(date != "NA,NA") %<>% mutate(date = str_replace_all(date, "Y,", "")) 
```

Rename records in `country`:

```{r}
distribution %<>% mutate(country = recode(country,
  "record_gb" = "Great Britain",
  "record_fr" = "France",
  "record_be" = "Belgium",
  "record_nl" = "The Netherlands"))
```

## Term mapping

Map the data to [Species Distribution](http://rs.gbif.org/extension/gbif/1.0/distribution.xml).

### taxonID

```{r}
distribution %<>% mutate(taxonID = raw_taxonID)
```

### locationID

```{r}
distribution %<>% mutate(locationID = case_when(
   country == "Great Britain" ~ " WGSRPD:GRB ",
   country == "France" ~ "ISO_3166-2:FR",
   country == "Belgium" ~ "ISO_3166-2:BE",
   country == "The Netherlands" ~ "ISO_3166-2:NL"))
```

### locality

```{r}
distribution %<>% mutate(locality = country)
```

### countryCode

```{r}
distribution %<>% mutate(countryCode = case_when(
   country == "Great Britain" ~ "GB",
   country == "France" ~ "FR",
   country == "Belgium" ~ "BE",
   country == "The Netherlands" ~ "NL"))
```

### occurrenceStatus

```{r}
distribution %<>% mutate(occurrenceStatus = "present") 
```

### establishmentMeans

```{r}
distribution %<>% mutate(establishmentMeans = "established") 
```

### eventDate

Inspect dates:

```{r}
distribution %>% distinct(date) %>% arrange(date)
```

Check whether date information deviates from the required ISO 8601 format(here `YYYY`)

```{r}
unique(distribution[which(str_detect(distribution $ date,"^[0-9]{4}$") == FALSE), "date"])
```

We clean these dates:

```{r}
distribution %<>% mutate(date = str_trim(date)) # remove whitespaces
```


```{r}
distribution %<>% mutate(date = recode(date,
   "n.d."  = "",
   "17634" = "1763",
   "2004," = "2004",
   "n..d"  = "",
   "199"   = "1990",
   "1985," = "1985",
   "NA"    = "",
   "19204" = "1904")) 
```

After this cleaning step, there should be no deviations from the ISO 8601 format:

```{r}
unique(distribution[which(str_detect(distribution $ date,"^[0-9]{4}$") == FALSE), "date"])
```

We want to express `eventDate` as the range between the date of first and last record. In this case, we don't have information about the last record. We'll consider the publication year of Zieritz et al. (2016) as the date when the presence of the species was last verified:

```{r}
distribution %<>% mutate(eventDate = case_when(
  date == "" ~ "",
  date != "" ~ paste(date, "2016", sep = "/"))) 
```

### source

Information about the source is provided in `raw_references`. We replace the sequence of reference numbers by the sequence of identifiers (not full references), provided in the dataframe `identifier_checklist` generated earlier.

```{r}
distribution %<>% left_join(identifier_sequence, by = ("raw_references"))
```

Rename `id_sequence`:

```{r}
distribution %<>%  rename("source" = "id_sequence")
```

## Post-processing

Remove the original columns:

```{r}
distribution %<>% select(-starts_with("raw_"), -country, -date)
```



Preview data:

```{r}
head(distribution)
```

Save to CSV:

```{r}
write.csv(distribution, file = dwc_distribution_file, na = "", row.names = FALSE, fileEncoding = "UTF-8")
```

# Create species profile extension

In this extension will express broad habitat characteristics (e.g. `isTerrestrial`) of the species.

```{r start_species_profile}
species_profile <- raw_data
```

Habitat information can be found in `raw_environment`, which describes whether a species is found in freshwater, terrestrial, marine or a combination of these habitats.

Show unique values:

```{r}
species_profile %>%
  select(raw_environment) %>%
  group_by_all() %>% 
  summarize(records = n())
```

Two taxa have no information on the environment, i.e. `Salvelinus fontalis` and `Rattus norvegicus`. 
`Salvelinus fontinalis` (brook trout) is fish found in both freshwater and marine habitats, while `Rattus norvegicus`(brown rat) is a terrestrial species. We add this information ourslves

We map this information respectively to `isFreshwater`, `isTerrestrial`, `isMarine` or a combination of these terms in the species profile extension.

## Term mapping

Map the data to [Species Profile](http://rs.gbif.org/extension/gbif/1.0/speciesprofile.xml).

### taxonID

```{r}
species_profile %<>% mutate(taxonID = raw_taxonID)
```

### isMarine

```{r}
species_profile %<>% mutate(isMarine = case_when(
  raw_environment == "M" |
  raw_environment == "M+F" |
  raw_environment == "T+M" | 
  raw_species == "Salvelinus fontinalis (Mitchill, 1814)" ~ "TRUE",
  TRUE ~ "FALSE"
))
```

### isFreshwater

```{r}
species_profile %<>% mutate(isFreshwater = case_when(
  raw_environment == "F" |
  raw_environment == "F,T" |
  raw_environment == "F+T" |
  raw_environment == "M+F" |
  raw_species == "Salvelinus fontinalis (Mitchill, 1814)" ~ "TRUE",
  TRUE ~ "FALSE"))
```

### isTerrestrial

```{r}
species_profile %<>% mutate(isTerrestrial = case_when(
  raw_environment == "F,T" |
  raw_environment == "F+T" |
  raw_environment == "T" |
  raw_environment == "T+M" |
  raw_species == "Rattus norvegicus (Berkenhout 1769)" ~ "TRUE",
  TRUE ~"FALSE"))
```

Show mapped values:

```{r}
species_profile %>%
  select(raw_environment, isMarine, isFreshwater, isTerrestrial) %>%
  group_by_all() %>%
  summarize(records = n())
```

## Post-processing

Remove the original columns:

```{r}
species_profile %<>% select(-starts_with("raw_"))
```

Sort on `taxonID`:

```{r}
species_profile %<>% arrange(taxonID)
```

Preview data:

```{r}
species_profile %>% head()
```

Save to CSV:

```{r}
write.csv(species_profile, file = dwc_profile_file, na = "", row.names = FALSE, fileEncoding = "UTF-8")
```


# Create description extension

In the description extension we want to include several important characteristics (hereafter refered to as descriptors) about the species:

- Native range
- Pathway of introduction

A single taxon can have multiple descriptions of the same type (e.g. multiple native ranges), expressed as multiple rows in the description extension.For each descriptor, we create a separate dataframe to process the specific information. We always specify _which descriptor_ we map (`type` column) and its _specific content_ (`description` column). After the mapping of these Darwin Core terms `type` and `value`, we merge the dataframes to generate one single description extension. We then continue the mapping process by adding the other Darwin Core terms (which content is independent of the type of descriptor, such as `language`).

## Native range

Native range information (e.g. `Australia`) can be found in `raw_origin`. 

Create separate dataframe:

```{r}
native_range <- raw_data
```

Show unique values:

```{r}
native_range %>% 
  distinct(raw_origin) %>% 
  arrange(raw_origin)
```

`raw_origin` contains multiple values (currently not more than 4), so we separate it in 4 columns:

```{r}
native_range %<>% separate(raw_origin, into = paste("origin", c(1:4), sep = "_"))
```

Gather in a `key` and `value` column:
 
```{r}
native_range %<>% gather("key", "value", paste("origin", c(1:4), sep = "_"), na.rm = TRUE) 
```

inspect values:

```{r}
native_range %>% 
  distinct(value) %>% 
  arrange(value)
```

Map values:

```{r}
native_range %<>% mutate(mapped_value = recode(value,
  "Af"  = "Africa (WGSRPD:2)",
  "Ar"  = "Arctic",
  "As"  = "Asia",
  "Au"  = "Australia (WGSRPD:50)",
  "Aus" = "Australia (WGSRPD:50)",
  "d"   = "",
  "Eu"  = "Europe (WGSRPD:1)",
  "n"   = "",
  "na"  = "",
  "NAm" = "Northern America (WGSRPD:7)",
  "SAm" = "Southern America (WGSRPD:8)"
)) 
```

Show mapped values:

```{r}
native_range %>%
  select(value, mapped_value) %>%
  group_by(value, mapped_value) %>%
  summarize(records = n()) 
```

Keep only non-empty descriptions:

```{r}
native_range %<>% filter(!is.na(mapped_value) & mapped_value != "")
```

Drop the `key` and `value` columns and rename `mapped_value` as `description`:

```{r}
native_range %<>%
  select(-key, -value) %>%
  rename(description = mapped_value)
```

Create a `type` field to indicate the type of description:

```{r}
native_range %<>% mutate(type = "native range")
```

## Pathway of introduction

Pathway information in this dataset is a combination of the columns starting with `raw_pathway_` (4 columns) and `raw_vector_` (5 columns).

Create separate dataframe:

```{r}
pathway_desc <- raw_data
```

Overview of the 9 columns relevant for this mapping:

```{r}
pathway_desc %>% select(starts_with("raw_vector"), starts_with("raw_pathway")) %>% 
  group_by_all() %>% 
  summarize(records = n()) 
```

For some taxa, no pathway information is provided, despite the fact that vector information is available. To indicate this, we create a new column `pathway_provided`, for which the value is `NO` for these specific species:

```{r}
pathway_desc %<>% mutate(pathway_provided = case_when(
  is.na(raw_pathway_accidental) &
  is.na(raw_pathway_dispersal) &
  is.na(raw_pathway_import_escape) &
  is.na(raw_pathway_import_release) ~ "NO",
  TRUE ~ "YES"
)) 
```

For some taxa, no vector information is provided, despite the fact that pathway information is available. To indicate this, we create a new column `vector_provided`, for which the value is `NO` for these specific species:

```{r}
pathway_desc %<>% mutate(vector_provided = case_when(
  is.na(raw_vector_biocontrol) &
  is.na(raw_vector_leisure) &
  is.na(raw_vector_industry) &
  is.na(raw_vector_ornamental) &
  is.na(raw_vector_research) ~ "NO",
  TRUE ~ "YES"
)) 
```

We combine this information in two new columns:
- `pathway`: containing the information in `raw_pathway_accidental`, `raw_pathway_disperal`, `raw_pathway_import_escape` and `raw_pathway_import_release`)
- `vector`: containing the information in `raw_vector_biocontrol`, `raw_vector_leisure`, `raw_vector_industry`, `raw_vector_ornamental`and `raw_vector_research`

```{r}
pathway_desc %<>% 
  gather("pathway", "pathway_value", starts_with("raw_pathway")) %<>% 
  gather("vector", "vector_value", starts_with("raw_vector"))
```

We need to filter out the following combinations:
- Rows for which `pathway_value` = NA and `vector_value` = NA,
- Rows for which `pathway_value` = "Y", `vector_value` = NA BUT vector_provided` = YES,
- Rows for which `pathway_value` = NA, `vector_value` = "Y" BUT vector_provided` = YES,

```{r}
pathway_desc %<>% filter(!(is.na(pathway_value) & is.na(vector_value)) &
                          !(pathway_value == "Y" & is.na(vector_value) & vector_provided == "YES") & 
                          !(is.na(pathway_value) & vector_value == "Y" & pathway_provided == "YES")) 
```

Overview of all possible combinations for pathway and vector:

```{r}
pathway_desc %>% 
  select(pathway, pathway_value, vector, vector_value) %>% 
  group_by_all() %>% 
  summarize(records = n())
```

All available pathway information will be mapped to the six main categories of the [CBD standard](https://www.cbd.int/doc/meetings/sbstta/sbstta-18/official/sbstta-18-09-add1-en.pdf). Vector information for which we have pathway information will be mapped to the subcategories of the CBD standard, but **only in certain cases**. For pathways `raw_pathway_disperal` and `raw_pathway_accidental`, we will **not** provide vector information. This is because vectors of accidentally introduced species were not analysed in the present study, due to a lack of reliable data (see Zieritz et al. 2016). For pathways `raw_pathway_import_escape` and `raw_pathway_import_release` , we will map vector information to the CBD standard **only** when they map unambigiously to one single CBD term (see also [this issue](https://github.com/trias-project/rinse-pathways-checklist/issues/3). For vectors without pathway information, we will only map the information to CBD categories/subcategories when the link is straigtforward.

RINSE pathway | RINSE vector | CBD category | CBD subcategory
--- | --- | --- | ---
accidental | biocontrol | stowaway | NA
accidental | industry | stowaway | NA
accidental | leisure | stowaway | NA
accidental | ornamental | stowaway | NA
accidental | research | stowaway | NA

accidental | biocontrol | contaminant | NA
accidental | industry | contaminant | NA
accidental | leisure | contaminant | NA
accidental | ornamental | contaminant | NA
accidental | research | contaminant | NA

dispersal | biocontrol | corridor | NA
dispersal | industry | corridor | NA
dispersal | leisure | corridor | NA
dispersal | ornamental | corridor | NA
dispersal | research | corridor | NA

dispersal | biocontrol | unaided | NA
dispersal | industry | unaided| NA
dispersal | leisure | unaided | NA
dispersal | ornamental | unaided| NA
dispersal | research | unaided | NA

import_escape | biocontrol | escape | NA
import_escape | industry | escape | NA
import_escape | leisure | escape | live food and bait
import_escape | ornamental | escape | NA 
import_escape | research | escape | Research and ex-situ breeding (in facilities)

import_release | biocontrol | release  | biological control
import_release | industry | release | NA
import_release | leisure | release | NA
import_release | ornamental | release | NA
import_release | research | release | NA

NA | biocontrol | release | biological control
NA | industry | |
NA | leisure | |
NA | ornamental | | 
NA | research | escape | biological control

We map this information in the new column `description`

```{r}
pathway_desc %>% mutate(description = case_when(
  pathway == "raw_pathway_accidental" & !is.na(pathway_value) ~ "stowaway | contaminant",
  pathway == "raw_pathway_dispersal" & !is.na(pathway_value) ~ "dispersal | unaided",
  pathway == "raw_pathway_import_escape" & !is.na(pathway_value) & vector == "raw_vector_leisure" & vector_value == "Y" ~ "escape_food_bait",
  pathway == "raw_pathway_import_escape" & !is.na(pathway_value) & vector == "raw_vector_leisure" & is.na(vector_value) ~ "escape",
  pathway == "raw_pathway_import_escape" & !is.na(pathway_value) & vector != "raw_vector_leisure"  ~ "escape",
  pathway == "raw_pathway_import_escape" & !is.na(pathway_value) & vector == "raw_vector_research" & vector_value == "Y" ~ "escape_research",
  pathway == "raw_pathway_import_escape" & !is.na(pathway_value) & vector == "raw_vector_research" & is.na(vector_value) ~ "escape",
  pathway == "raw_pathway_import_escape" & !is.na(pathway_value) & vector != "raw_vector_research" ~ "escape",
  pathway == "raw_pathway_import_release" & !is.na(pathway_value) & vector == "raw_vector_biocontrol" & vector_value == "Y" ~ "release_biocontrol",
  pathway == "raw_pathway_import_release" & !is.na(pathway_value) & vector == "raw_vector_biocontrol" & is.na(vector_value) ~ "release",
  pathway == "raw_pathway_import_release" & !is.na(pathway_value) & vector != "raw_vector_biocontrol" ~ "release",
  is.na(pathway_value) & vector == "raw_vector_biocontrol" ~ "release_biocontrol",
  is.na(pathway_value) & vector == "raw_vector_research" ~ "escape_biocontrol")) %>% View()
```


 
