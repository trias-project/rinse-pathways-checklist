---
title: "Darwin Core mapping"
subtitle: "For: RINSE - pathways and vectors of biological invasions in Northwest Europe"
author:
- Lien Reyserhove
- Peter Desmet
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    number_sections: true
---

This document describes how we map the checklist data to Darwin Core. The source file for this document can be found [here](https://github.com/trias-project/rinse-pathways-checklist/tree/master/data/raw).

# Setup

```{r setup, echo = FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

Set locale (so we use UTF-8 character encoding):

```{r}
# This works on Mac OS X, might not work on other OS
Sys.setlocale("LC_CTYPE", "en_US.UTF-8")
```

Load libraries:

```{r}
library(tidyverse) # To transform data
library(magrittr)  # For %<>% pipes
library(janitor)   # To clean input data
library(readxl)    # To read Excel files
library(stringr)   # To perform string operations
library(digest)    # To generate hashes
library(rgbif)     # Interface to the GBIF API
library(purrr)     # To clean references
```

Set file paths (all paths should be relative to this script):
 
```{r}
# Raw files:
raw_data_file = "../data/raw/copy_of_10530_2016_1278_MOESM2_ESM.xlsx"
references = "../data/raw/references.xlsx"

# Processed files:
dwc_taxon_file = "../data/processed/taxon.csv"
dwc_literature_references_file = "../data/processed/literature_references.csv"
dwc_distribution_file = "../data/processed/distribution.csv"
dwc_profile_file = "../data/processed/speciesprofile.csv"
dwc_description_file = "../data/processed/description.csv"
```

# Read and pre-process raw data

Create a data frame `raw_data` from the source data:

```{r}
raw_data <- read_excel(path = raw_data_file) 
```

Clean the data somewhat: remove empty rows if present and clean names:

```{r}
raw_data %<>% remove_empty_rows() %<>%     # Remove empty rows
  clean_names()
```

## Clean scientific name

Before we assign a taxonID to the scientific names (in `species`), we need to clean the information. We do this stepwise by using the `parsenames()` function provided by rgbif. 

```{r}
parsed_names <- parsenames(raw_data $ species)
```

In this checklist, all specificEpithets should be populated. This is not always the case. Some cleaning was required:

```{r}
raw_data %<>% mutate(species_clean = case_when(
  species == "Crassostrea rhizophoraeGuilding 1828" ~ "Crassostrea rhizophorae Guilding 1828",
  species == "Petricola pholadiformisLamarck, 1818" ~ "Petricola pholadiformis Lamarck, 1818",
  species == "Theba pisanaMüller, 1774)" ~ "Theba pisana (Müller, 1774)",
  species == "Maylandia sp. M. K. Meyer & W. Förster, 1984" ~ "Maylandia M. K. Meyer & W. Förster, 1984",
  TRUE ~ species)) 
```

## Generate taxonID

To uniquely identify a taxon in the taxon core and reference taxa in the extensions, we need a `taxonID`. Since we need it in all generated files, we generate it here in the raw data frame. It is a combination of `dataset-shortname:taxon:` and a hash based on the scientific name. As long as the scientific name doesn't change, the ID will be stable:

```{r}
# Vectorize the digest function (The digest() function isn't vectorized. So if you pass in a vector, you get one value for the whole vector rather than a digest for each element of the vector):
vdigest <- Vectorize(digest)

# Generate taxonID:
raw_data %<>% mutate(taxonID = paste("rinse-pathways-checklist", "taxon", vdigest (species_clean, algo="md5"), sep=":"))
```

## Further pre-processing:

Add prefix `raw_` to all column names to avoid name clashes with Darwin Core terms:

```{r}
colnames(raw_data) <- paste0("raw_", colnames(raw_data))
```

Preview data:

```{r}
raw_data %>% head()
```

# Create taxon core

```{r start_taxon}
taxon <- raw_data
```

## Term mapping
 
Map the data to [Darwin Core Taxon](http://rs.gbif.org/core/dwc_taxon_2015-04-24.xml).
 
### language

```{r}
taxon %<>% mutate(language = "en")
```

### rightsHolder

```{r}
taxon %<>% mutate(rightsHolder = "University of Cambridge")
```

### datasetID

```{r}
taxon %<>% mutate(datasetID = "")
```

### datasetName

```{r}
taxon %<>% mutate(datasetName = "RINSE - pathways and vectors of biological invasions in Northwest Europe")
```

### taxonID

```{r}
taxon %<>% mutate(taxonID = raw_taxonID)
```

### scientificName

```{r}
taxon %<>% mutate(scientificName = raw_species_clean)
```

### kingdom

Information for the higher classification is contained in `raw_higher_classification`:

```{r}
taxon %>% distinct(raw_higher_classification)
```

These map to different taxonomical levels (e.g. `Mammalia` = class while `Osteichthyes` = order). We interpret this information in the mapping of `kingdom`, `phylum`, `class` and `order`. However, not all classification information could be mapped to these Darwin Core terms, e.g. Angiosperms are currently considered to be unranked. For this group, we use the Darwin Core terms `higherClassification`.

```{r}
taxon %<>% mutate(kingdom = case_when(
  raw_higher_classification == "Angiospermae" ~ "Plantae" ,
  TRUE ~ "Animalia")) 
```

### phylum

```{r}
taxon %<>% mutate(phylum = case_when(
  raw_higher_classification == "Angiospermae" ~ "" ,
  raw_higher_classification == "Mollusca" ~ "Mollusca",
  TRUE ~ "Chordata")) 
```

### class

```{r}
taxon %<>% mutate(class = case_when(
  raw_higher_classification == "Anseriformes" ~ "Aves",
  raw_higher_classification == "Mammalia" ~ "Mammalia",
  raw_higher_classification == "Osteichthyes" ~ "Actinopterygii",  # Osteichthyes is an unaccepted synonym
  TRUE ~ "")) 
```

### order

```{r}
taxon %<>% mutate(order = case_when(
  raw_higher_classification == "Anseriformes" ~ "Anseriformes",
  TRUE ~ "" )) 
```

### higherClassification

```{r}
taxon %<>% mutate(higherClassification = case_when(
  raw_higher_classification == "Angiospermae" ~ paste(kingdom, raw_higher_classification, sep = " | "),
  raw_higher_classification == "Mollusca" ~ paste(kingdom, phylum, sep = " | "),
  raw_higher_classification == "Osteichthyes" ~ paste(kingdom, phylum, class, sep = " | "),
  raw_higher_classification == "Anseriformes" ~ paste(kingdom, phylum, class, order, sep = " | "),
  raw_higher_classification == "Mammalia" ~ paste(kingdom, phylum, class, sep = " | "))) 
```

### taxonRank

The information for `taxonRank` can be provided by the nameparser() function of rgbif. We generate it here and add the information to `taxon`:

```{r}
taxonRank <- parsenames(taxon $ raw_species_clean)
```

Select taxonRank information (in `rankmarker`). The field `notho` contains valuable information for the generic hybrids, so this column is selected as well. 

```{r}
taxonRank %<>% select(scientificname, rankmarker, notho) 
```

Merge `taxonRank` with `taxon`:

```{r}
taxon %<>% left_join(taxonRank, by = c("raw_species_clean" = "scientificname")) 
```

Show unique values for `rankmarker`:

```{r}
taxon %>% select(rankmarker, notho) %>% 
  group_by_all() %>% 
  summarise(records = n())
```

Show scientificNames for which rankmarker = NA:

```{r}
taxon %>% select(scientificName, rankmarker) %>% 
  filter(is.na(rankmarker))
```

`Maylandia M. K. Meyer & W. Förster, 1984` is a genus, the other two records are species.
Map `taxonRank`:

```{r}
taxon %<>% mutate(taxonRank = case_when(
  !is.na(notho) ~ "hybrid",
  rankmarker == "sp." & is.na(notho) ~ "species",
  rankmarker == "infrasp." ~ "subspecies",
  is.na(rankmarker) & scientificName != "Maylandia M. K. Meyer & W. Förster, 1984" ~ "species",
  scientificName == "Maylandia M. K. Meyer & W. Förster, 1984" ~ "genus")) 
```

## Post-processing

Remove the original columns:

```{r}
taxon %<>% select(-starts_with("raw_"), -rankmarker, - notho)
```

Preview data:

```{r}
head(taxon)
```

Save to CSV:

```{r}
write.csv(taxon, file = dwc_taxon_file, na = "", row.names = FALSE, fileEncoding = "UTF-8")
```

# Create literature reference extension

Map the data to [Literature References](http://rs.gbif.org/extension/gbif/1.0/references.xml).

```{r}
literature_references <- raw_data
```

## Pre-processing

Clean `raw_references`: 

```{r}
colon_to_seq <- function(input){
  seq_locs <- gregexpr("\\d+-\\d+", input)
  matched <- regmatches(input, seq_locs)[[1]]
  
  split_support <- function(text) {
    split_seq <- strsplit(text, "-")[[1]]
    paste(as.character(seq(split_seq[1], split_seq[2])), collapse = ",")
  }
  
  regmatches(input, seq_locs, invert = FALSE) <- list(map_chr(matched, split_support))
  input
}
```

Apply cleaning functions:

```{r}
literature_references %<>% 
  rowwise() %<>%
  mutate(raw_references = colon_to_seq(raw_references)) 
```

```{r}
literature_references %<>%
  mutate(references_sep = raw_references) %<>% 
  ungroup() %<>%
  separate_rows(references_sep, sep = ",")
```

Import references file:

```{r}
compiled_references <- read_excel(path = references, col_types = "text")
```

Merge `literature_references` with `compiled_references`:

```{r}
literature_references %<>% left_join(compiled_references, by = c("references_sep" = "number"))
```

Generate dataframe `identifier` with one column containing the full combination of identifiers:

```{r}
identifiers <- literature_references %>% select(raw_taxonID, raw_references,references_sep, identifier) %>% mutate(references_sep = as.numeric(references_sep))
```

```{r}
identifiers %<>% spread(references_sep, identifier) %<>% select(-`<NA>`)
```

```{r}
old_names <- c("raw_taxonID", "raw_references", c(1:33))
new_names <- c("raw_taxonID", "raw_references", paste("ref", c(1:33), sep = ":"))
```


```{r}
identifiers %<>% rename_at(vars(old_names), ~ new_names) 
```


```{r}
identifiers %<>% unite("id_united", c(paste("ref", c(1:33), sep = ":")), sep = " | ")
```

```{r}
identifiers %<>% mutate(id_united = str_replace_all(id_united, "(([NA]{2}\\s[|]) | [|]\\s([NA]{2}))", ""))
```

## Term mapping

### taxonID

```{r}
literature_references %<>% mutate(taxonID = raw_taxonID)
```

### identifier

```{r}
literature_references %<>% select(-identifier, everything()) 
```

### bibliographicCitation

```{r}
literature_references %<>% mutate(bibliographicCitation = full_reference) 
```

## Post-processing

Remove the original columns:

```{r}
literature_references %<>% select(-starts_with("raw_"), -references_sep, -full_reference)
```

Preview data:

```{r}
head(literature_references)
```

Save to CSV:

```{r}
write.csv(literature_references, file = dwc_literature_references_file, na = "", row.names = FALSE, fileEncoding = "UTF-8")
```

# Create distribution extension

Map the data to [Species Distribution](http://rs.gbif.org/extension/gbif/1.0/distribution.xml).

```{r}
distribution <- raw_data
```

### pre-processing

Check wether each record for which `raw_presence_gb` = NA --> raw_first_record_gb = NA

```{r}
distribution %>% filter((is.na(raw_established_gb) & !is.na(raw_first_record_gb))) 
```


```{r}
distribution %>% filter((is.na(raw_established_france) & !is.na(raw_first_record_france)))
```

```{r}
distribution %>% filter((is.na(raw_established_belgium) & !is.na(raw_first_record_belgium)))
```

```{r}
distribution %>% filter((is.na(raw_established_netherlands) & !is.na(raw_first_record_netherlands)))
```

Paste date and establishment information for each country:

```{r}
distribution %<>% mutate(record_gb = paste(raw_established_gb, raw_first_record_gb, sep = ",")) 
```

```{r}
distribution %<>% mutate(record_fr = paste(raw_established_france, raw_first_record_france, sep = ",")) 
```

```{r}
distribution %<>% mutate(record_be = paste(raw_established_belgium, raw_first_record_belgium, sep = ",")) 
```

```{r}
distribution %<>% mutate(record_nl = paste(raw_established_netherlands, raw_first_record_netherlands, sep = ",")) 
```

Frow wide to long dataset:

```{r}
distribution %<>% gather("country", "date", record_gb, record_fr, record_be, record_nl) 
```

Remove records with `NA,NA`:

```{r}
distribution %<>% filter(date != "NA,NA") 
```

Clean `data`:

```{r}
distribution %<>% mutate(date = str_replace_all(date, "Y,", "")) 
```

Rename `country`:

```{r}
distribution %<>% mutate(country = recode(country,
  "record_gb" = "Great Britain",
  "record_fr" = "France",
  "record_be" = "Belgium",
  "record_nl" = "The Netherlands"))
```

## Term mapping

### taxonID

```{r}
distribution %<>% mutate(taxonID = raw_taxonID)
```

### locationID

```{r}
distribution %<>% mutate(locationID = case_when(
   country == "Great Britain" ~ "ISO_3166-2:GB",
   country == "France" ~ "ISO_3166-2:FR",
   country == "Belgium" ~ "ISO_3166-2:BE",
   country == "The Netherlands" ~ "ISO_3166-2:NL"))
```

### locality

```{r}
distribution %<>% mutate(locality = country)
```

### countryCode

```{r}
distribution %<>% mutate(countryCode = case_when(
   country == "Great Britain" ~ "GB",
   country == "France" ~ "FR",
   country == "Belgium" ~ "BE",
   country == "The Netherlands" ~ "NL"))
```

### occurrenceStatus

```{r}
distribution %<>% mutate(occurrenceStatus = "present") 
```

### establishmentMeans

```{r}
distribution %<>% mutate(establishmentMeans = "established") 
```

### eventDate

Inspect dates:

```{r}
distribution %>% distinct(date) %>% arrange(date)
```

Clean whitespace information:

```{r}
unique(distribution[which(str_detect(distribution $ date,"^[0-9]{4}$") == FALSE), "date"])
```


```{r}
distribution %<>% mutate(date = str_trim(date)) 
```


```{r}
distribution %<>% mutate(date = recode(date,
   "n.d."  = "",
   "17634" = "1763",
   "2004," = "2004",
   "n..d"  = "",
   "199"   = "1990",
   "1985," = "1985",
   "NA"    = "",
   "19204" = "1904")) 
```

```{r}
unique(distribution[which(str_detect(distribution $ date,"^[0-9]{4}$") == FALSE), "date"])
```

Make date range:

```{r}
distribution %<>% mutate(eventDate = case_when(
  date == "" ~ "",
  date != "" ~ paste(date, "2016", sep = "/"))) 
```

### source



## Post-processing

Remove the original columns:

```{r}
distribution %<>% select(-starts_with("raw_"), -country, -date)
```

Preview data:

```{r}
head(distribution)
```

Save to CSV:

```{r}
write.csv(distribution, file = dwc_distribution_file, na = "", row.names = FALSE, fileEncoding = "UTF-8")
```

# Create resource relationship extension

```{r start_resource_relationship}
resource_relationship <- raw_data
```

## Term mapping

Map the data to [Resource Relationship](http://rs.gbif.org/extension/dwc/resource_relation_2018_01_18.xml).

# Create species profile extension

In this extension will express broad habitat characteristics (e.g. `isTerrestrial`) of the species.

```{r start_species_profile}
species_profile <- raw_data
```

Habitat information can be found in `raw_environment`, which describes whether a species is found in freshwater, terrestrial, marine or a combination of these habitats.

Show unique values:

```{r}
species_profile %>%
  distinct(raw_environment) %>%
  arrange(raw_environment)
```

We map this information respectively to `isFreshwater`, `isTerrestrial`, `isMarine` or a combination of these terms in the species profile extension.

## Term mapping

Map the data to [Species Profile](http://rs.gbif.org/extension/gbif/1.0/speciesprofile.xml).

### taxonID

```{r}
species_profile %<>% mutate(taxonID = raw_taxonID)
```

### isMarine

```{r}
species_profile %<>% mutate(isMarine = case_when(
  raw_environment == "M" |
    raw_environment == "M+F" |
    raw_environment == "T+M" ~ "TRUE",
  TRUE ~ "FALSE"
))
```

### isFreshwater

```{r}
species_profile %<>% mutate(isFreshwater = case_when(
  raw_environment == "F" |
    raw_environment == "F,T" |
    raw_environment == "F+T" |
    raw_environment == "M+F" ~ "TRUE",
  TRUE ~ "FALSE"))
```

### isTerrestrial

```{r}
species_profile %<>% mutate(isTerrestrial = case_when(
  raw_environment == "F,T" |
    raw_environment == "F+T" |
    raw_environment == "T" |
    raw_environment == "T+M" ~ "TRUE",
  TRUE ~"FALSE"))
```

Show mapped values:

```{r}
species_profile %>%
  select(raw_environment, isMarine, isFreshwater, isTerrestrial) %>%
  group_by_all() %>%
  summarize(records = n())
```

## Post-processing

Remove the original columns:

```{r}
species_profile %<>% select(-starts_with("raw_"))
```

Sort on `taxonID`:

```{r}
species_profile %<>% arrange(taxonID)
```

Preview data:

```{r}
species_profile %>% head()
```

Save to CSV:

```{r}
write.csv(species_profile, file = dwc_profile_file, na = "", row.names = FALSE, fileEncoding = "UTF-8")
```


# Create description extension

In the description extension we want to include several important characteristics (hereafter refered to as descriptors) about the species:

- Native range
- Pathway of introduction

A single taxon can have multiple descriptions of the same type (e.g. multiple native ranges), expressed as multiple rows in the description extension.

For each descriptor, we create a separate dataframe to process the specific information. We always specify _which descriptor_ we map (`type` column) and its _specific content_ (`description` column). After the mapping of these Darwin Core terms `type` and `value`, we merge the dataframes to generate one single description extension. We then continue the mapping process by adding the other Darwin Core terms (which content is independent of the type of descriptor, such as `language`).

```{r}
description_ext <- raw_data
```


## Native range

```{r}
native_range <- raw_data
```


```{r}
native_range %>% distinct(raw_origin)
```

separate on comma:

```{r}
native_range %<>% separate(raw_origin, into = paste("origin", c(1:4)))
```

From wide to long dataset:

```{r}
native_range %<>% gather("descriptor", "origin", paste("origin", c(1:4)), na.rm = TRUE) 
```

inspect values:

```{r}
native_range %>% distinct(origin) 
```

recode values:

```{r}
native_range %<>% mutate(native_range = recode(origin,
  "Aus" = "Australia (WGSRPD:50)",
  "Au"  = "Australia (WGSRPD:50)",
  "NAm" = "Northern America (WGSRPD:7)",
  "As"  = "Asia",
  "Af"  = "Africa (WGSRPD:2)",
  "SAm" = "Southern America (WGSRPD:8)",
  "Eu"  = "Europe (WGSRPD:1)",
  "Ar"  = "Arctic",
  "na"  = "",
  "n"   = "",
  "d"   = "")) 
```

Show mapped values:

```{r}
native_range %>%
  select(origin, native_range) %>%
  group_by(origin, native_range) %>%
  summarize(records = n()) 
```

Keep only non-empty descriptions:

```{r}
native_range %<>% filter(!is.na(native_range) & native_range != "")
```

Create a `type` field to indicate the type of description:

```{r}
native_range %<>% mutate(type = "native range")
```

Clean `native_range`:

```{r}
native_range %<>% select(-descriptor, -origin) 
```

## Pathway of introduction

```{r}
pathway_desc <- raw_data
```

Combi van pathways en vectoren nodig:

```{r}
pathway_desc %<>% gather("pathway", "value", starts_with("raw_pathway"))
```

```{r}
pathway_desc %<>% gather("vector", "value2", starts_with("raw_vector"))
```

```{r}
pathway_desc %<>% filter(value == "Y" & value2 == "Y") 
```

Overview of all possible combinations for pathway and vector:

```{r}
pathway_desc %>% 
  select(pathway, vector) %>% 
  group_by_all() %>% 
  summarize(records = n())
```

```{r}
pathway_desc %>% filter(pathway == "raw_pathway_import_relaese" & vector == "raw_vector_research1")
```

